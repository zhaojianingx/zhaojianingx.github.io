<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>ML</title>
    <link href="/2023/01/12/ML/"/>
    <url>/2023/01/12/ML/</url>
    
    <content type="html"><![CDATA[<h2 id="机器学习的基本流程">机器学习的基本流程</h2><ol><li><p>Function with Unknown Parameters</p><p><strong>Model</strong>   $$ y = b + wx^1$$  based on domain knowledge              <strong>Features</strong>   x    <strong>Label</strong>   y</p></li><li><p>Define Loss from Training Data</p><ul><li><p>Loss is a function of parameters       <strong>L(b, w)</strong></p></li><li><p>Loss: how good a set of values is</p><p>$$e =  \left | y - \widehat{y } \right | $$       Loss:   $$L = \frac{1}{N} \sum_{n}e_{n}$$</p></li></ul></li><li><p>Optimization        $w^<em>, b^</em> = arg \min \limits_{w,b} L$</p><p>Gradient Descent (梯度下降法)</p><ul><li><p>(Randomly) Pick an initial value $w^0$, $b^0$</p></li><li><p>Computer</p><p>$\frac{\partial L}{\partial w} |<em>{w = w^0, b = b^0}$          $w^1 \longleftarrow w^0 - \eta\frac{\partial L}{\partial w} |</em>{w = w^0, b = b^0}$</p><p>$\frac{\partial L}{\partial b} |<em>{w = w^0, b = b^0}$            $b^1 \longleftarrow b^0 - \eta\frac{\partial L}{\partial b} |</em>{w = w^0, b = b^0}$</p></li><li><p>Update w and b iteratively</p></li></ul></li></ol><h2 id="常用概念">常用概念</h2><p>1 epoch = see all the batches once</p><p>每次更新一次参数叫做一次Update</p><p>Hyperameter</p><ul><li>Batch size</li><li>Learning rate</li></ul><p>Activation function</p><ul><li><p>sigmoid</p></li><li><p>ReLu</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树</title>
    <link href="/2023/01/01/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2023/01/01/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h2 id="二叉树的存储">二叉树的存储</h2><p><strong>二叉树可以链式存储，也可以顺序存储。</strong></p><p>那么链式存储方式就用指针， 顺序存储的方式就是用数组。</p><p>顾名思义就是顺序存储的元素在内存是连续分布的，而链式存储则是通过指针把分布在各个地址的节点串联一起。</p><h3 id="顺序存储">顺序存储</h3><img src="/2023/01/01/%E4%BA%8C%E5%8F%89%E6%A0%91/image-20230101123934975.png" class="" title="image-20230101123934975"><p>用数组来存储二叉树如何遍历的呢？</p><p><strong>如果父节点的数组下标是 i，那么它的左孩子就是 i * 2 + 1，右孩子就是 i * 2 + 2。</strong></p><h3 id="链式存储">链式存储</h3><img src="/2023/01/01/%E4%BA%8C%E5%8F%89%E6%A0%91/image-20230101123901687.png" class="" title="image-20230101123901687"><p>C++代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TreeNode</span> <br>&#123;<br>    <span class="hljs-type">int</span> val;<br>    TreeNode* left;<br>    TreeNode* right;<br>    <span class="hljs-built_in">TreeNode</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">val</span>(x), <span class="hljs-built_in">left</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">right</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="二叉树的遍历">二叉树的遍历</h2><h3 id="深度优先遍历（DFS）">深度优先遍历（DFS）</h3><p>基本思想就是<strong>先往深走，遇到叶子节点再往回走</strong>。</p><p>遍历方式：（前中后指的是<strong>中间节点的遍历顺序</strong>）</p><ol><li><p>前序遍历</p><ul><li><p>递归法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* cur, vector&lt;<span class="hljs-type">int</span>&gt;&amp; vec)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<br>        vec.<span class="hljs-built_in">push_back</span>(cur-&gt;val); <span class="hljs-comment">// 中</span><br>        <span class="hljs-built_in">traversal</span>(cur-&gt;left, vec); <span class="hljs-comment">// 左</span><br>        <span class="hljs-built_in">traversal</span>(cur-&gt;right, vec); <span class="hljs-comment">// 右</span><br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        <span class="hljs-built_in">traversal</span>(root, result);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>迭代法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        stack&lt;TreeNode*&gt; st;<br>        <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">nullptr</span>) st.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>()) &#123;<br>            TreeNode* node = st.<span class="hljs-built_in">top</span>();<br>            <span class="hljs-keyword">if</span> (node != <span class="hljs-literal">nullptr</span>) &#123;<br>                st.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span> (node-&gt;right) st.<span class="hljs-built_in">push</span>(node-&gt;right);  <span class="hljs-comment">// 右</span><br>                <span class="hljs-keyword">if</span> (node-&gt;left) st.<span class="hljs-built_in">push</span>(node-&gt;left);    <span class="hljs-comment">// 左</span><br>                st.<span class="hljs-built_in">push</span>(node);                          <span class="hljs-comment">// 中</span><br>                st.<span class="hljs-built_in">push</span>(<span class="hljs-literal">nullptr</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                st.<span class="hljs-built_in">pop</span>();<br>                node = st.<span class="hljs-built_in">top</span>();<br>                st.<span class="hljs-built_in">pop</span>();<br>                result.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>中序遍历</p><ul><li><p>递归法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* cur, vector&lt;<span class="hljs-type">int</span>&gt;&amp; vec)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-built_in">traversal</span>(cur-&gt;left, vec); <span class="hljs-comment">// 左</span><br>        vec.<span class="hljs-built_in">push_back</span>(cur-&gt;val); <span class="hljs-comment">// 中 </span><br>        <span class="hljs-built_in">traversal</span>(cur-&gt;right, vec); <span class="hljs-comment">// 右  </span><br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        <span class="hljs-built_in">traversal</span>(root, result);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>迭代法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        stack&lt;TreeNode*&gt; st;<br>        <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">nullptr</span>) st.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>()) &#123;<br>            TreeNode* node = st.<span class="hljs-built_in">top</span>();<br>            <span class="hljs-keyword">if</span> (node != <span class="hljs-literal">nullptr</span>) &#123;<br>                st.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span> (node-&gt;right) st.<span class="hljs-built_in">push</span>(node-&gt;right); <span class="hljs-comment">// 右</span><br>                st.<span class="hljs-built_in">push</span>(node);                         <span class="hljs-comment">// 中</span><br>                st.<span class="hljs-built_in">push</span>(<span class="hljs-literal">nullptr</span>);<br>                <span class="hljs-keyword">if</span> (node-&gt;left) st.<span class="hljs-built_in">push</span>(node-&gt;left);   <span class="hljs-comment">// 左</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                st.<span class="hljs-built_in">pop</span>();<br>                node = st.<span class="hljs-built_in">top</span>();<br>                st.<span class="hljs-built_in">pop</span>();<br>                result.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>后序遍历</p><ul><li><p>递归法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* cur, vector&lt;<span class="hljs-type">int</span>&gt;&amp; vec)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-built_in">traversal</span>(cur-&gt;left, vec); <span class="hljs-comment">// 左</span><br>        <span class="hljs-built_in">traversal</span>(cur-&gt;right, vec); <span class="hljs-comment">// 右</span><br>        vec.<span class="hljs-built_in">push_back</span>(cur-&gt;val); <span class="hljs-comment">// 中 </span><br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        <span class="hljs-built_in">traversal</span>(root, result);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>迭代法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        stack&lt;TreeNode*&gt; st;<br>        <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">nullptr</span>) st.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>()) &#123;<br>            TreeNode* node = st.<span class="hljs-built_in">top</span>();<br>            <span class="hljs-keyword">if</span> (node != <span class="hljs-literal">nullptr</span>) &#123;<br>                st.<span class="hljs-built_in">pop</span>();<br>                st.<span class="hljs-built_in">push</span>(node);                               <span class="hljs-comment">// 中</span><br>                st.<span class="hljs-built_in">push</span>(<span class="hljs-literal">nullptr</span>);<br>                <span class="hljs-keyword">if</span> (node-&gt;right) st.<span class="hljs-built_in">push</span>(node-&gt;right);       <span class="hljs-comment">// 右</span><br>                <span class="hljs-keyword">if</span> (node-&gt;left) st.<span class="hljs-built_in">push</span>(node-&gt;left);         <span class="hljs-comment">// 左       </span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                st.<span class="hljs-built_in">pop</span>();<br>                node = st.<span class="hljs-built_in">top</span>();<br>                st.<span class="hljs-built_in">pop</span>();<br>                result.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul></li></ol><h3 id="广度优先遍历-（BFS）">广度优先遍历 （BFS）</h3><p>基本思想是<strong>一层一层地去遍历</strong>。</p><p>遍历方式：</p><ol><li>层次遍历<ul><li><p>迭代法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">levelOrder</span>(TreeNode* root) &#123;<br>        queue&lt;TreeNode*&gt; que;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>        <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">nullptr</span>) que.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-type">int</span> size = que.<span class="hljs-built_in">size</span>();<br>            vector&lt;<span class="hljs-type">int</span>&gt; vec;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; ++i) &#123;<br>                TreeNode* node = que.<span class="hljs-built_in">front</span>();<br>                que.<span class="hljs-built_in">pop</span>();<br>                vec.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>                <span class="hljs-keyword">if</span> (node-&gt;left) que.<span class="hljs-built_in">push</span>(node-&gt;left);<br>                <span class="hljs-keyword">if</span> (node-&gt;right) que.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            &#125;<br>            result.<span class="hljs-built_in">push_back</span>(vec);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序算法</title>
    <link href="/2022/12/31/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <url>/2022/12/31/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h3 id="冒泡排序">冒泡排序</h3><h3 id="选择排序">选择排序</h3><p>C++代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SelectionSort</span><span class="hljs-params">(<span class="hljs-type">int</span>* array, <span class="hljs-type">int</span> size)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// Step through each element of the array</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> startIndex&#123; <span class="hljs-number">0</span> &#125;; startIndex &lt; (size - <span class="hljs-number">1</span>); ++startIndex)<br>    &#123;<br>        <span class="hljs-comment">// smallestIndex is the index of the smallest element we&#x27;ve encountered so far</span><br>        <span class="hljs-type">int</span> smallestIndex&#123; startIndex &#125;;<br><br>        <span class="hljs-comment">// Look for smallest element remaining in the array (starting at startIndex + 1)</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> currentIndex&#123; startIndex + <span class="hljs-number">1</span> &#125;; currentIndex &lt; size; ++currentIndex)<br>        &#123;<br>            <span class="hljs-comment">// If the current element is smaller than our previously found smallest</span><br>            <span class="hljs-keyword">if</span> (array[smallestIndex] &gt; array[currentIndex]) <span class="hljs-comment">// COMPARISON DONE HERE</span><br>            &#123;<br>                <span class="hljs-comment">// This is the new smallest number for thie iteration</span><br>                smallestIndex = currentIndex;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// Swap our start element with our smallest element</span><br>        std::<span class="hljs-built_in">swap</span>(array[startIndex], array[smallestIndex]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="归并排序">归并排序</h3>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC 2037.使每位学生都有座位的最少移动次数</title>
    <link href="/2022/12/31/2037%E4%BD%BF%E6%AF%8F%E4%BD%8D%E5%AD%A6%E7%94%9F%E9%83%BD%E6%9C%89%E5%BA%A7%E4%BD%8D%E7%9A%84%E6%9C%80%E5%B0%91%E7%A7%BB%E5%8A%A8%E6%AC%A1%E6%95%B0%EF%BC%88%E7%AE%80%E5%8D%95%EF%BC%89/"/>
    <url>/2022/12/31/2037%E4%BD%BF%E6%AF%8F%E4%BD%8D%E5%AD%A6%E7%94%9F%E9%83%BD%E6%9C%89%E5%BA%A7%E4%BD%8D%E7%9A%84%E6%9C%80%E5%B0%91%E7%A7%BB%E5%8A%A8%E6%AC%A1%E6%95%B0%EF%BC%88%E7%AE%80%E5%8D%95%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h3 id="题目描述">题目描述</h3><p>这是Leecode上的 <a href="https://leetcode.cn/problems/minimum-number-of-moves-to-seat-everyone/"><strong>2037. 使每位学生都有座位的最少移动次数</strong></a>，难度为 <strong>简单</strong>。</p><p>一个房间里有 n 个座位和 n 名学生，房间用一个数轴表示。给你一个长度为 n 的数组 seats ，其中 seats[i] 是第 i 个座位的位置。同时给你一个长度为 n 的数组 students ，其中 students[j] 是第 j 位学生的位置。</p><p>你可以执行以下操作任意次：</p><p>增加或者减少第 i 位学生的位置，每次变化量为 1 （也就是将第 i 位学生从位置 x 移动到 x + 1 或者 x - 1）<br>请你返回使所有学生都有座位坐的最少移动次数 ，并确保没有两位学生的座位相同。</p><p>请注意，初始时有可能有多个座位或者多位学生在同一 位置。</p><p>示例 1：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：seats = [3,1,5], students = [2,7,4]<br>输出：4<br>解释：学生移动方式如下：<br><br>- 第一位学生从位置<span class="hljs-number"> 2 </span>移动到位置<span class="hljs-number"> 1 </span>，移动<span class="hljs-number"> 1 </span>次。<br>- 第二位学生从位置<span class="hljs-number"> 7 </span>移动到位置<span class="hljs-number"> 5 </span>，移动<span class="hljs-number"> 2 </span>次。<br>- 第三位学生从位置<span class="hljs-number"> 4 </span>移动到位置<span class="hljs-number"> 3 </span>，移动<span class="hljs-number"> 1 </span>次。<br>  总共<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 1 </span>=<span class="hljs-number"> 4 </span>次移动。<br></code></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：seats = [4,1,5,9], students = [1,3,2,6]<br>输出：7<br>解释：学生移动方式如下：<br><br>- 第一位学生不移动。<br>- 第二位学生从位置<span class="hljs-number"> 3 </span>移动到位置<span class="hljs-number"> 4 </span>，移动<span class="hljs-number"> 1 </span>次。<br>- 第三位学生从位置<span class="hljs-number"> 2 </span>移动到位置<span class="hljs-number"> 5 </span>，移动<span class="hljs-number"> 3 </span>次。<br>- 第四位学生从位置<span class="hljs-number"> 6 </span>移动到位置<span class="hljs-number"> 9 </span>，移动<span class="hljs-number"> 3 </span>次。<br>  总共<span class="hljs-number"> 0 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 3 </span>=<span class="hljs-number"> 7 </span>次移动。<br></code></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：seats = [2,2,6,6], students = [1,3,2,6]<br>输出：4<br>解释：学生移动方式如下：<br><br>- 第一位学生从位置<span class="hljs-number"> 1 </span>移动到位置<span class="hljs-number"> 2 </span>，移动<span class="hljs-number"> 1 </span>次。<br>- 第二位学生从位置<span class="hljs-number"> 3 </span>移动到位置<span class="hljs-number"> 6 </span>，移动<span class="hljs-number"> 3 </span>次。<br>- 第三位学生不移动。<br>- 第四位学生不移动。<br>  总共<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 0 </span>+<span class="hljs-number"> 0 </span>=<span class="hljs-number"> 4 </span>次移动。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><p>n == seats.length == students.length</p></li><li><p>1 &lt;= n &lt;= 100</p></li><li><p>1 &lt;= seats[i], students[j] &lt;= 100</p></li></ul><hr><h3 id="贪心-排序">贪心 + 排序</h3><p>分别给两个vector排序后，累加差值的绝对值即可。</p><p>C++代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minMovesToSeat</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; seats, vector&lt;<span class="hljs-type">int</span>&gt;&amp; students)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(seats.<span class="hljs-built_in">begin</span>(), seats.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">sort</span>(students.<span class="hljs-built_in">begin</span>(), students.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> ans&#123;<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; seats.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            ans += <span class="hljs-built_in">abs</span>(seats[i] - students[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leecode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>贪心</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cpp学习记录</title>
    <link href="/2022/12/30/cpp%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <url>/2022/12/30/cpp%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h3 id="学习路线">学习路线</h3><ul><li>[ ] <a href="https://www.learncpp.com/">LEARN C++</a></li><li>[ ] c++ Primer</li></ul>]]></content>
    
    
    <categories>
      
      <category>cpp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC 459.重复的子字符串</title>
    <link href="/2022/12/30/459%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%88%E7%AE%80%E5%8D%95%EF%BC%89/"/>
    <url>/2022/12/30/459%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%88%E7%AE%80%E5%8D%95%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h3 id="题目描述">题目描述</h3><p>这是Leecode上的 <a href="https://leetcode.cn/problems/repeated-substring-pattern/"><strong>459. 重复的子字符串</strong></a>，难度为 <strong>简单</strong>。</p><p>给定一个非空的字符串 s ，检查是否可以通过由它的一个子串重复多次构成。</p><p>示例 1:</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入: <span class="hljs-attr">s</span> = <span class="hljs-string">&quot;abab&quot;</span><br>输出: <span class="hljs-literal">true</span><br>解释: 可由子串 <span class="hljs-string">&quot;ab&quot;</span> 重复两次构成。<br></code></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入: <span class="hljs-attr">s</span> = <span class="hljs-string">&quot;aba&quot;</span><br>输出: <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>示例 3:</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入: <span class="hljs-attr">s</span> = <span class="hljs-string">&quot;abcabcabcabc&quot;</span><br>输出: <span class="hljs-literal">true</span><br>解释: 可由子串 <span class="hljs-string">&quot;abc&quot;</span> 重复四次构成。 (或子串 <span class="hljs-string">&quot;abcabc&quot;</span> 重复两次构成。)<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>1 &lt;= s.length &lt;= 10<sup>4</sup></li><li>s 由小写英文字母组成</li></ul><hr><h3 id="KMP算法">KMP算法</h3><p>假设字符串s是由重复的子串构成设重复出现的子字符串长度是x，所以s是由n * x组成的。</p><p>因为字符串s的最长相同前后缀的长度一定是不包含s本身，所以最长相同前后缀长度必然是m * x，而且n - m = 1。</p><p>所以如果nx % (n - m)x = 0， 就可以判定有重复出现的子字符串。</p><p>根据KMP算法，next数组记录的就是<strong>最长相同前后缀</strong>。</p><p>C++代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getNext</span><span class="hljs-params">(<span class="hljs-type">int</span>* next, <span class="hljs-type">const</span> string&amp; s)</span> </span>&#123;<br>        <span class="hljs-comment">// 1) 初始化</span><br>        <span class="hljs-type">int</span> j&#123;<span class="hljs-number">-1</span>&#125;;<br>        next[<span class="hljs-number">0</span>] = j;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; s.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            <span class="hljs-comment">// 2）处理前后缀不相同的情况</span><br>            <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; s[i] != s[j + <span class="hljs-number">1</span>]) &#123;<br>                j = next[j];<br>            &#125;<br>            <span class="hljs-comment">// 3）处理前后缀相同的情况</span><br>            <span class="hljs-keyword">if</span> (s[i] == s[j + <span class="hljs-number">1</span>]) &#123;<br>                j++;<br>            &#125;<br>            next[i] = j;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">repeatedSubstringPattern</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> len = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> next[s.<span class="hljs-built_in">size</span>()];<br>        <span class="hljs-built_in">getNext</span>(next, s);<br>        <span class="hljs-keyword">return</span> (next[len - <span class="hljs-number">1</span>] != <span class="hljs-number">-1</span> &amp;&amp; len % (len - (next[len - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>)) == <span class="hljs-number">0</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leecode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>KMP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python学习记录</title>
    <link href="/2022/12/30/Python%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <url>/2022/12/30/Python%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h3 id="学习路线">学习路线</h3><ul><li><p>[x] <a href="https://www.youtube.com/watch?v=t8pPdKYpowI&amp;t=1195s">Python Tutorial for Beginners - Learn Python in 5 Hours [FULL COURSE]</a></p></li><li><p>[ ] <a href="https://docs.python.org/3/tutorial/index.html">The Python Tutorial</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cpp常用代码规范</title>
    <link href="/2022/12/30/cpp%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    <url>/2022/12/30/cpp%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/</url>
    
    <content type="html"><![CDATA[<h3 id="变量名">变量名</h3><p>采用小驼峰命名法</p><p>类的成员变量前加m_</p><h3 id="类名">类名</h3><p>采用大驼峰命名法，首字母大写</p>]]></content>
    
    
    <categories>
      
      <category>cpp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>代码规范</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LC 855.考场就座</title>
    <link href="/2022/12/30/855%E8%80%83%E5%9C%BA%E5%B0%B1%E5%BA%A7%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/"/>
    <url>/2022/12/30/855%E8%80%83%E5%9C%BA%E5%B0%B1%E5%BA%A7%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h3 id="题目描述">题目描述</h3><p>这是Leecode上的 <a href="https://leetcode.cn/problems/exam-room/"><strong>855. 考场就座</strong> </a>，难度为 <strong>中等</strong>。</p><p>在考场里，一排有 N 个座位，分别编号为 0, 1, 2, …, N-1 。</p><p>当学生进入考场后，他必须坐在能够使他与离他最近的人之间的距离达到最大化的座位上。如果有多个这样的座位，他会坐在编号最小的座位上。(另外，如果考场里没有人，那么学生就坐在 0 号座位上。)</p><p>返回 ExamRoom(int N) 类，它有两个公开的函数：其中，函数 ExamRoom.seat() 会返回一个 int （整型数据），代表学生坐的位置；函数 ExamRoom.leave(int p) 代表坐在座位 p 上的学生现在离开了考场。每次调用 ExamRoom.leave§ 时都保证有学生坐在座位 p 上。</p><p>示例：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：<span class="hljs-selector-attr">[<span class="hljs-string">&quot;ExamRoom&quot;</span>,<span class="hljs-string">&quot;seat&quot;</span>,<span class="hljs-string">&quot;seat&quot;</span>,<span class="hljs-string">&quot;seat&quot;</span>,<span class="hljs-string">&quot;seat&quot;</span>,<span class="hljs-string">&quot;leave&quot;</span>,<span class="hljs-string">&quot;seat&quot;</span>]</span>, <span class="hljs-selector-attr">[[10]</span>,<span class="hljs-selector-attr">[]</span>,<span class="hljs-selector-attr">[]</span>,<span class="hljs-selector-attr">[]</span>,<span class="hljs-selector-attr">[]</span>,<span class="hljs-selector-attr">[4]</span>,<span class="hljs-selector-attr">[]</span>]<br>输出：<span class="hljs-selector-attr">[null,0,9,4,2,null,5]</span><br>解释：<br><span class="hljs-function"><span class="hljs-title">ExamRoom</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span> -&gt; null<br><span class="hljs-function"><span class="hljs-title">seat</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-number">0</span>，没有人在考场里，那么学生坐在 <span class="hljs-number">0</span> 号座位上。<br><span class="hljs-function"><span class="hljs-title">seat</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-number">9</span>，学生最后坐在 <span class="hljs-number">9</span> 号座位上。<br><span class="hljs-function"><span class="hljs-title">seat</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-number">4</span>，学生最后坐在 <span class="hljs-number">4</span> 号座位上。<br><span class="hljs-function"><span class="hljs-title">seat</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-number">2</span>，学生最后坐在 <span class="hljs-number">2</span> 号座位上。<br><span class="hljs-function"><span class="hljs-title">leave</span><span class="hljs-params">(<span class="hljs-number">4</span>)</span></span> -&gt; null<br><span class="hljs-function"><span class="hljs-title">seat</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-number">5</span>，学生最后坐在 <span class="hljs-number">5</span> 号座位上。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>1 &lt;= N &lt;= 10<sup>9</sup></li><li>在所有的测试样例中 ExamRoom.seat() 和 ExamRoom.leave() 最多被调用 10<sup>4</sup> 次。</li><li>保证在调用 ExamRoom.leave§ 时有学生正坐在座位 p 上。</li></ul><hr><h3 id="利用set维护有序序列">利用set维护有序序列</h3><p>0 1 2 3 4 5 6 7 8 9</p><p>1     *      1              1</p><p>利用set有序的特点来记录已经有人坐的座位，根据set中有人的座位，将所有座位可以分成不同的段，比较每段距离的差值的一半，找到最大值，即找到离学生最近的人之间的距离达到最大化的座位</p><p>C++代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ExamRoom</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    set&lt;<span class="hljs-type">int</span>&gt; s; <span class="hljs-comment">// 有人的位置</span><br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-built_in">ExamRoom</span>(<span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-keyword">this</span>-&gt;n = n;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">seat</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 无人的时候插入位置为0</span><br>            s.<span class="hljs-built_in">insert</span>(<span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> l = <span class="hljs-number">-1</span>, r = <span class="hljs-number">0</span>; <span class="hljs-comment">// 左右节点</span><br>        <span class="hljs-type">int</span> max = <span class="hljs-number">0</span>; <span class="hljs-comment">// 最大距离</span><br>        <span class="hljs-type">int</span> insertNum = <span class="hljs-number">0</span>; <span class="hljs-comment">// 要插入的位置</span><br>        <span class="hljs-keyword">if</span> (*s.<span class="hljs-built_in">begin</span>() != <span class="hljs-number">0</span>) max = *s.<span class="hljs-built_in">begin</span>(); <span class="hljs-comment">// 判断0不存在时，插入0是否合适</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i = s.<span class="hljs-built_in">begin</span>(); i != s.<span class="hljs-built_in">end</span>(); ++i) &#123;<br>            r = *i;<br>            <span class="hljs-keyword">if</span> (max &lt; (r - l) / <span class="hljs-number">2</span>) &#123; <span class="hljs-comment">// 判断插入目前两个节点中间是否合适</span><br>                max = (r - l) / <span class="hljs-number">2</span>;<br>                insertNum = l + (r - l) / <span class="hljs-number">2</span>;<br>            &#125;<br>            l = r;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (r != n - <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 判断n - 1不存在的时候，插入n - 1是否合适</span><br>            <span class="hljs-keyword">if</span> (max &lt; n - <span class="hljs-number">1</span> - r) insertNum = n - <span class="hljs-number">1</span>;<br>        &#125;<br>        s.<span class="hljs-built_in">insert</span>(insertNum);<br>        <span class="hljs-keyword">return</span> insertNum;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">leave</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;<br>        s.<span class="hljs-built_in">erase</span>(p);<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your ExamRoom object will be instantiated and called as such:</span><br><span class="hljs-comment"> * ExamRoom* obj = new ExamRoom(n);</span><br><span class="hljs-comment"> * int param_1 = obj-&gt;seat();</span><br><span class="hljs-comment"> * obj-&gt;leave(p);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leecode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
